# !/user/bin/python# -*- coding:utf-8 -*-"""date：          2022-04-15Description :    【并查集】：        1. 查询两个元素是否在一个集合中        2. 合并两个集合        3. 以上两个操作要在常数时间内    要理解并查集的使用场景，为什么一定要使用并查集，其他数据结构为什么就不行或者不好？auther : wcy"""# import modulesimport os, typing__all__ = []# define classclass Node(object):    __slots__ = ["value", "next_node"]    def __init__(self, v):        self.value = v        self.next_node = None    def set_next_node(self, node):        self.next_node = node        return self    def __hash__(self):        return self.valueclass UnionSet(object):    def __init__(self, data_set: typing.Set[int]):        self.value_to_node: typing.Dict[int, Node] = {}        for data in data_set:            node = Node(v=data)            next_node = Node(v=None)            node.set_next_node(node=next_node)            self.value_to_node[data] = node    def is_in_same_set(self, v1, v2):        if v1 in self.value_to_node:            v1_node, v1_final_node, v1_depth, v1_node_path = self.get_final_next_node(v1)        else:            v1_node, v1_final_node = None, None        if v2 in self.value_to_node:            v2_node, v2_final_node, v2_depth, v2_node_path = self.get_final_next_node(v2)        else:            v2_node, v2_final_node = None, None        # 优化查找路径        if v1_final_node:            for p_node in v1_node_path:                p_node.set_next_node(v1_final_node)        if v2_final_node:            for p_node in v2_node_path:                p_node.set_next_node(v2_final_node)        # 判断返回结果        if v1_final_node is None or v2_final_node is None or id(v1_final_node) != id(v2_final_node):            return False        else:            return True    def get_final_next_node(self, v):        node = self.value_to_node[v]        depth = 1        node_path: typing.List[None] = [node]        while True:            next_node = node.next_node            if next_node.next_node is None:                break            node = node.next_node            if node.value is not None:                node_path.append(node)            depth += 1        return node, next_node, depth, node_path    def union_set(self, v1, v2):        # get node and depth        if v1 in self.value_to_node:            v1_node, v1_final_node, v1_depth, v1_node_path = self.get_final_next_node(v1)        else:            v1_node, v1_final_node = None, None        if v2 in self.value_to_node:            v2_node, v2_final_node, v2_depth, v2_node_path = self.get_final_next_node(v2)        else:            v2_node, v2_final_node = None, None        if v1_final_node is None or v2_final_node is None:            return        # union set        if v1_depth > v2_depth:            v2_final_node.set_next_node(v1_final_node)        else:            v1_final_node.set_next_node(v2_final_node)        pass# define functiondef func(m):    island_num = 0    return island_num# define maindef main():    union_set = UnionSet(data_set={1, 2, 3, 4, 5})    print(union_set.is_in_same_set(1, 2))    union_set.union_set(1, 2)    print(union_set.is_in_same_set(1, 2))    union_set.union_set(3, 4)    print(union_set.is_in_same_set(2, 3))    union_set.union_set(2, 3)    print(union_set.is_in_same_set(2, 3))# mainif __name__ == '__main__':    main()